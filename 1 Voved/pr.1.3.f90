program primer1_3
  implicit none
  ! ---------------------------------------------------------------
  ! ОПСЕГ НА ЦЕЛОБРОЈНИ (INTEGER) ВРЕДНОСТИ 
  !
  ! Дел А) 
  !   Почнуваме со N = -1 и во секој чекор го удвојуваме (N = N*2).
  !   Печатиме I, N и -N. Ова илустрира:
  !     • раст на |N| до минималниот INT (асиметричен опсег),
  !     • дека -N не може да стане +|MIN| (непостоечки број),
  !     • и, по натамошно удвојување, „превртување“ (wrap/overflow).
  !
  ! Дел Б) Приказ во К-битна репрезентација:
  !   За K = 8:  MAX = 2^(K-1) - 1 = 127
  !              MIN = -2^(K-1)    = -128
  !
  ! Напомена: „со единечна прецизност“ кај цели броеви практично значи
  ! „стандардниот (default) INTEGER“ на машината (најчесто 32-битен).
  ! ---------------------------------------------------------------

  integer :: i
  integer :: n          ! тековна целобројна вредност
  integer :: m, isum    ! помошни за K-битната сума (дел Б)
  integer, parameter :: K = 8  ! како во оригиналниот пример со збир до 2^(K-2)

  ! ------------------------- Дел А -------------------------------
  n = -1
  print '(A)', 'ДЕЛ А) Удвојување од N = -1 (N = N*2):'
  print *, 'huge(INTEGER) =', huge(n)   ! очекувано 2147483647 за 32-битен INT
  print '(A)', '   i                  N                  -N'
  do i = 1, 33
     n = n * 2
     ! На минималниот INT, изразот -N може да не е претставлив
     ! како позитивен број – токму тоа сакаме да го видиме/истакнеме.
     write (*,'(I4,1X,I20,3X,I20)') i, n, -n
  end do

  print *
  ! ------------------------- Дел Б -------------------------------
  ! K-битна презентација со знак:
  !   Сума = 1 + 2 + 4 + ... + 2^(K-2) = 2^(K-1) - 1  → MAX
  !   За K = 8: 1+2+4+8+16+32+64 = 127
  !
  ! Потоа, „огледалото“ со негативни степени:
  !   -1 -2 -4 - ... - 2^(K-2) = - (2^(K-1) - 1)
  !   и уште минус 1 → -2^(K-1)  → MIN

  ! Позитивна сума (MAX)
  m    = 1
  isum = 1
  do i = 1, K-2
    m    = m * 2
    isum = isum + m
  end do
  print *, 'MAX (2^(K-1)-1) = ', isum       ! 127 за K=8
  print *, 'MAX + 1  -> wrap -> MIN = -2^(K-1)  (-128 кај K=8)' 
  
  ! Негативна „огледална“ сума (до -127), па уште -1 -> -128
  m    = -1
  isum = -1
  do i = 1, K-2
    m    = m * 2
    isum = isum + m
  end do
  print *, 'MIN (-2^(K-1))    = ', isum - 1  ! -128
  print *, 'MIN + 1 -> -127'


end program primer1_3
